(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[2398],{5636:function(e,t,n){Promise.resolve().then(n.bind(n,72705))},18968:function(e,t,n){"use strict";n.d(t,{G:function(){return ContractAlertLayout},Z:function(){return ContractAlert}});var a=n(57437),r=n(69394),s=n(59494),o=n(18269),i=n(26158);function ContractAlertLayout(e){let{children:t}=e;return(0,a.jsxs)("div",{className:"my-3 flex items-center justify-center",children:[(0,a.jsx)("div",{className:"mr-2",children:(0,a.jsx)(r.LPM,{width:12,height:12})}),(0,a.jsx)("div",{className:"text-xs",children:t})]})}function ContractAlert(e){let{contract:t,amount:n}=e,{isConnected:r}=(0,o.m)(),c=(0,i.p)((0,s.f)(String(n)));return r?"onUnsupportedNetwork"===t.status?(0,a.jsxs)(ContractAlertLayout,{children:["Please connect to one of the supported networks to continue:"," ",t.supportedChains.map(e=>e.name).join(", ")]}):"deactivated"===t.status?(0,a.jsx)(ContractAlertLayout,{children:"This contract has been deactivated on this chain."}):c?null:(0,a.jsxs)(ContractAlertLayout,{children:["You must have at least ",String(n)," ETH in your wallet to continue."]}):(0,a.jsx)(ContractAlertLayout,{children:"Please connect your wallet to continue."})}},72705:function(e,t,n){"use strict";n.r(t),n.d(t,{default:function(){return PaymasterBundlerPage}});var a=n(57437),r=n(87196),s=n(46522),o=n(52630),i=n(2265),c=n(54104),l=n(50096);function NewGuide(){(0,l.Bn)();let e=(0,i.useMemo)(()=>[{href:"#introduction",label:"Paymasters (Sponsored Transactions)"},{href:"#choosing-paymaster",label:"Choose a paymaster service provider"},{href:"#setting-proxy",label:"(Recommended) Setup your paymaster proxy"},{href:"#send-eip-5792-requests",label:"Send EIP-5792 Requests"}],[]);return(0,a.jsxs)("div",{children:[(0,a.jsx)(l.H3,{id:"guide",children:"Guide to Using Smart Wallets with Sponsored Transactions"}),(0,a.jsxs)("div",{className:"gap-16 lg:flex",children:[(0,a.jsxs)("main",{className:"w-full flex-shrink-0 flex-grow xl:max-w-[900px]",children:[(0,a.jsx)(l.Hr,{}),(0,a.jsxs)(l.$0,{id:"introduction",children:[(0,a.jsx)(l.H4,{children:"Paymasters (Sponsored Transactions)"}),(0,a.jsxs)(l.P,{children:["One of the biggest UX enhancements unlocked by Smart Wallet is the ability for app developers to sponsor their users' transactions. If your app supports Smart Wallet, you can start sponsoring your users' transactions by using"," ",(0,a.jsx)(l.A,{href:"https://www.erc7677.xyz/introduction",children:"standardized paymaster service communication"}),(0,a.jsx)(l.A,{href:"https://www.eip5792.xyz/introduction",children:"enabled by new wallet RPC methods"}),". This code is also in our"," ",(0,a.jsx)(l.A,{href:"https://github.com/wilsoncusack/wagmi-scw/",children:"Wagmi Smart Wallet template"}),"."]})]}),(0,a.jsxs)(l.$0,{id:"choosing-paymaster",children:[(0,a.jsx)(l.H4,{children:"1. Choose a Paymaster Service Provider"}),(0,a.jsx)(l.P,{children:"As a prerequisite, you'll need to obtain a paymaster service URL from a paymaster service provider. To be compatible with Smart Wallet, the paymaster provider you choose must be ERC-7677-compliant."}),(0,a.jsxs)(l.P,{children:["We recommend the ",(0,a.jsx)(l.A,{href:"https://login.coinbase.com",children:"Coinbase Developer Platform"})," ","paymaster. You can find a full list of ERC-7677-compliant paymaster services"," ",(0,a.jsx)(l.A,{href:"https://www.erc7677.xyz/ecosystem/paymasters",children:"here"}),"."]}),(0,a.jsx)(l.P,{children:"Once you choose a paymaster service provider and obtain a paymaster service URL, you can proceed to integration."})]}),(0,a.jsxs)(l.$0,{id:"setting-proxy",children:[(0,a.jsx)(l.H4,{children:"2. (Recommended) Set Up Your Paymaster Proxy"}),(0,a.jsx)(l.P,{children:"Creating an API to proxy calls to your paymaster service is important for two reasons:"}),(0,a.jsxs)(l.Ul,{children:[(0,a.jsx)(l.Li,{children:"It allows you to protect any API secret."}),(0,a.jsx)(l.Li,{children:"It allows you to add extra validation on what requests you want to sponsor."})]}),(0,a.jsx)(l.H4,{children:"Validate UserOperation"}),(0,a.jsxs)(l.P,{children:['Before we write our proxy, let\'s write a willSponsor function to add some extra validation. The policies on many paymaster services are quite simple and limited. As your API will be exposed on the web, you want to make sure it cannot be abused: called to sponsor transactions you do not want to fund. The checks below are a bit tedious, but highly recommended to be safe. See "Trust and Validation"'," ",(0,a.jsx)(l.A,{href:"https://hackmd.io/@AhweV9sISeevhvrtVPCGDw/BynRsX7Ca#Trust-and-Validation",children:"here"})," ","for more on this. The code below is built specifically for Smart Wallets; it would need to be updated to support other smart accounts."]}),(0,a.jsx)(c.Z,{code:'```javascript\nimport { ENTRYPOINT_ADDRESS_V06, UserOperation } from "permissionless";\nimport {\n  Address,\n  BlockTag,\n  Hex,\n  decodeAbiParameters,\n  decodeFunctionData,\n} from "viem";\nimport { baseSepolia } from "viem/chains";\nimport {client} from "./config"\nimport {\n  coinbaseSmartWalletABI,\n  coinbaseSmartWalletProxyBytecode,\n  coinbaseSmartWalletV1Implementation,\n  erc1967ProxyImplementationSlot,\n  magicSpendAddress\n} from "./constants"\nimport { myNFTABI, myNFTAddress } from "./myNFT";\n \nexport async function willSponsor({\n  chainId,\n  entrypoint,\n  userOp,\n}: { chainId: number; entrypoint: string; userOp: UserOperation<"v0.6"> }) {\n  // check chain id\n  if (chainId !== baseSepolia.id) return false;\n  // check entrypoint\n  // not strictly needed given below check on implementation address, but leaving as example\n  if (entrypoint.toLowerCase() !== ENTRYPOINT_ADDRESS_V06.toLowerCase())\n    return false;\n \n  try {\n    // check the userOp.sender is a proxy with the expected bytecode\n    const code = await client.getBytecode({ address: userOp.sender });\n    if (code != coinbaseSmartWalletProxyBytecode) return false;\n \n    // check that userOp.sender proxies to expected implementation\n    const implementation = await client.request<{\n      Parameters: [Address, Hex, BlockTag];\n      ReturnType: Hex;\n    }>({\n      method: "eth_getStorageAt",\n      params: [userOp.sender, erc1967ProxyImplementationSlot, "latest"],\n    });\n    const implementationAddress = decodeAbiParameters(\n      [{ type: "address" }],\n      implementation,\n    )[0];\n    if (implementationAddress != coinbaseSmartWalletV1Implementation)\n      return false;\n \n    // check that userOp.callData is making a call we want to sponsor\n    const calldata = decodeFunctionData({\n      abi: coinbaseSmartWalletABI,\n      data: userOp.callData,\n    });\n \n    // keys.coinbase.com always uses executeBatch\n    if (calldata.functionName !== "executeBatch") return false;\n    if (!calldata.args || calldata.args.length == 0) return false;\n \n    const calls = calldata.args[0] as {\n      target: Address;\n      value: bigint;\n      data: Hex;\n    }[];\n    // modify if want to allow batch calls to your contract\n    if (calls.length > 2) return false;\n \n    let callToCheckIndex = 0;\n    if (calls.length > 1) {\n      // if there is more than one call, check if the first is a magic spend call\n      if (calls[0].target.toLowerCase() !== magicSpendAddress.toLowerCase())\n        return false;\n      callToCheckIndex = 1;\n    }\n \n    if (\n      calls[callToCheckIndex].target.toLowerCase() !==\n      myNFTAddress.toLowerCase()\n    )\n      return false;\n \n    const innerCalldata = decodeFunctionData({\n      abi: myNFTABI,\n      data: calls[callToCheckIndex].data,\n    });\n    if (innerCalldata.functionName !== "safeMint") return false;\n \n    return true;\n  } catch (e) {\n    console.error(`willSponsor check failed: ${e}`);\n    return false;\n  }\n}\n```',language:"javascript"})]}),(0,a.jsxs)(l.$0,{id:"setting-proxy",children:[(0,a.jsx)(l.H4,{children:"Create Proxy"}),(0,a.jsx)(l.P,{children:"The proxy you create will need to handle the pm_getPaymasterStubData and pm_getPaymasterData JSON-RPC requests specified by ERC-7677."}),(0,a.jsx)(c.Z,{code:'```javascript\nimport { paymasterClient } from "./config";\nimport { willSponsor } from "./utils";\n \nexport async function POST(r: Request) {\n  const req = await r.json();\n  const method = req.method;\n  const [userOp, entrypoint, chainId] = req.params;\n  console.log(req.params);\n  if (!willSponsor({ chainId: parseInt(chainId), entrypoint, userOp })) {\n    return Response.json({ error: "Not a sponsorable operation" });\n  }\n \n  if (method === "pm_getPaymasterStubData") {\n    const result = await paymasterClient.getPaymasterStubData({\n      userOperation: userOp,\n    });\n    return Response.json({ result });\n  } else if (method === "pm_getPaymasterData") {\n    const result = await paymasterClient.getPaymasterData({\n      userOperation: userOp,\n    });\n    return Response.json({ result });\n  }\n  return Response.json({ error: "Method not found" });\n}\n```',language:"javascript"})]}),(0,a.jsxs)(l.$0,{id:"send-eip-5792-requests",children:[(0,a.jsx)(l.H4,{children:"3. Send EIP-5792 Requests with a Paymaster Service Capability"}),(0,a.jsx)(l.P,{children:"Once you have your paymaster service set up, you can now pass its URL along to Wagmi's useWriteContracts hook. If you set up a proxy in your app's backend as recommended in step (2) above, you'll want to pass in the proxy URL you created."}),(0,a.jsx)(c.Z,{code:'```javascript\nimport { useAccount } from "wagmi";\nimport { useCapabilities, useWriteContracts } from "wagmi/experimental";\nimport { useMemo, useState } from "react";\nimport { CallStatus } from "./CallStatus";\nimport { myNFTABI, myNFTAddress } from "./myNFT";\n \nexport function App() {\n  const account = useAccount();\n  const [id, setId] = useState<string | undefined>(undefined);\n  const { writeContracts } = useWriteContracts({\n    mutation: { onSuccess: (id) => setId(id) },\n  });\n  const { data: availableCapabilities } = useCapabilities({\n    account: account.address,\n  });\n  const capabilities = useMemo(() => {\n    if (!availableCapabilities || !account.chainId) return {};\n    const capabilitiesForChain = availableCapabilities[account.chainId];\n    if (\n      capabilitiesForChain["paymasterService"] &&\n      capabilitiesForChain["paymasterService"].supported\n    ) {\n      return {\n        paymasterService: {\n          url: `${document.location.origin}/api/paymaster`,\n        },\n      };\n    }\n    return {};\n  }, [availableCapabilities]);\n \n  return (\n    <div>\n      <h2>Transact With Paymaster</h2>\n      <p>{JSON.stringify\n        <p>{JSON.stringify(capabilities)}</p>\n(capabilities)}</p>\n      <div>\n        <button\n          onClick={() => {\n            writeContracts({\n              contracts: [\n                {\n                  address: myNFTAddress,\n                  abi: myNFTABI,\n                  functionName: "safeMint",\n                  args: [account.address],\n                },\n              ],\n              capabilities,\n            });\n          }}\n        >\n          Mint\n        </button>\n        {id && <CallStatus id={id} />}\n      </div>\n    </div>\n  );\n}\n```',language:"javascript"}),(0,a.jsx)(l.P,{children:"That's it! Smart Wallet will handle the rest. If your paymaster service is able to sponsor the transaction, Smart Wallet will indicate to your user that the transaction is sponsored."})]})]}),(0,a.jsx)(l.o5,{title:"Guide to Sponsored Transactions",contents:e})]}),(0,a.jsxs)(l.P,{children:[(0,a.jsx)("strong",{children:"See full documentation here:"})," ",(0,a.jsx)(l.A,{href:"https://www.smartwallet.dev/",children:"Smart Wallet Documentation"})," "]})]})}var u=n(57042),d=n(18269),p=n(23588),m=n(76384),h=n(67333),f=n(27878),y=n(4832),g=n(21693),b=n(39630);async function sendCalls(e,t){let{account:n=e.account,calls:a,capabilities:r,chain:s=e.chain,version:o="1.0"}=t;if(!n)throw new h.o({docsPath:"/experimental/actions/sendCalls"});let i=(0,y.T)(n);if(!s)throw new f.Bk;try{return await e.request({method:"wallet_sendCalls",params:[{calls:a.map(e=>({...e,value:e.value?(0,g.eC)(e.value):void 0})),capabilities:r,chainId:(0,g.eC)(s.id),from:i.address,version:o}]},{retryCount:0})}catch(e){throw(0,b.$)(e,{...t,account:i,chain:t.chain})}}async function writeContracts(e,t){let n=t.contracts,a=n.map(e=>{let{address:t,abi:n,functionName:a,args:r,value:s}=e;return{data:(0,m.R)({abi:n,functionName:a,args:r}),to:t,value:s}});return sendCalls(e,{...t,calls:a})}var w=n(71660);async function writeContracts_writeContracts(e,t){let{account:n,chainId:a,connector:r,...s}=t,o=await (0,w.e)(e,{account:n,chainId:a,connector:r});return writeContracts(o,{...s,...n?{account:n}:{},chain:a?{id:a}:void 0})}var x=n(41012),v=n(18968),C=n(39485),j=n(87923),S=n(97832);let P=(0,S.R)({abi:[{stateMutability:"nonpayable",type:"function",inputs:[{name:"to",type:"address"}],name:"safeMint",outputs:[]}],[j.L.id]:{chain:j.L,address:"0x119Ea671030FBf79AB93b436D2E20af6ea469a19"}});var A=n(76026),N=n(21637),I=n(30838),T=n(3324);async function getCallsStatus(e,t){let{id:n}=t,{receipts:a,status:r}=await e.request({method:"wallet_getCallsStatus",params:[n]});return{status:r,receipts:a?.map(e=>({...e,blockNumber:I.y_(e.blockNumber),gasUsed:I.y_(e.gasUsed),status:T.ew[e.status]}))??[]}}async function getCallsStatus_getCallsStatus(e,t){let{connector:n,id:a}=t,r=await (0,w.e)(e,{connector:n});return getCallsStatus(r,{id:a})}var O=n(84855);function CallStatus(e){var t;let{id:n}=e,{data:r}=function(e){let{query:t={}}=e,n=(0,x.Z)(e),a={async queryFn({queryKey:e}){let{scopeKey:t,...a}=e[1],r=await getCallsStatus_getCallsStatus(n,a);return r},queryKey:["callsStatus",(0,N.OP)(e)],retry:(e,t)=>!(t instanceof A.aH)&&e<3};return(0,O.aM)({...t,...a})}({id:n,query:{refetchInterval:e=>{var t;return(null===(t=e.state.data)||void 0===t?void 0:t.status)!=="CONFIRMED"&&1e3}}});return(0,a.jsxs)("div",{children:[(0,a.jsx)("br",{}),(0,a.jsx)("strong",{children:"Status:"})," ",null!==(t=null==r?void 0:r.status)&&void 0!==t?t:"loading"]})}var k=n(25566);let B=function(){let e=(0,C._F)();return e===C.qA.localhost}(),_=B?k.env.NEXT_PUBLIC_PAYMASTER_URL:"https://".concat(k.env.NEXT_PUBLIC_VERCEL_PROJECT_PRODUCTION_URL,"/api/paymaster-proxy");function PaymasterBundlerDemo(){let{address:e}=(0,d.m)(),{data:t,writeContracts:n}=function(e={}){let{mutation:t}=e,n=(0,x.Z)(e),{mutate:a,mutateAsync:r,...s}=(0,p.D)({...t,mutationFn:e=>writeContracts_writeContracts(n,e),mutationKey:["writeContracts"]});return{...s,writeContracts:a,writeContractsAsync:r}}(),r=P();return"ready"!==r.status?(console.error("Contract is not ready"),null):(0,a.jsxs)("div",{className:(0,u.Z)("flex w-full flex-col items-center justify-center text-white"),children:[(0,a.jsxs)("section",{className:(0,u.Z)("mb-5 w-full max-w-3xl rounded-lg bg-gray-900 p-6 shadow-md"),children:[(0,a.jsx)("header",{children:(0,a.jsx)("h2",{className:(0,u.Z)("border-b-2 border-gray-700 pb-2 text-xl font-semibold"),children:"Account Details"})}),e&&(0,a.jsxs)("div",{className:(0,u.Z)("mt-2 text-lg"),children:[(0,a.jsx)("strong",{children:"Smart Wallet Address:"})," ",e]})]}),(0,a.jsxs)("section",{className:(0,u.Z)("w-full max-w-3xl rounded-lg bg-gray-900 p-6 shadow-md"),children:[(0,a.jsx)("header",{children:(0,a.jsx)("h1",{className:(0,u.Z)("border-b-2 border-gray-700 pb-2 text-center text-2xl font-bold"),children:"Mint NFTs with Coinbase Paymaster"})}),!e&&(0,a.jsx)(v.G,{children:"Please connect your wallet to continue."}),(0,a.jsx)("button",{type:"button",className:(0,u.Z)("mt-4 block w-full rounded-full py-3.5 text-lg font-bold text-white transition duration-300",e?"cursor-pointer bg-blue-600 hover:bg-blue-700":"cursor-not-allowed bg-gray-600"),onClick:e?()=>{n({contracts:[{address:r.address,abi:r.abi,functionName:"safeMint",args:[e]}],capabilities:{paymasterService:{url:_}}})}:void 0,disabled:!e,children:"Mint NFT"}),t&&(0,a.jsx)(CallStatus,{id:t})]})]})}function PaymasterBundlerPage(){return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.Z,{}),(0,a.jsxs)(o.Z,{children:[(0,a.jsx)(r.Z,{pageName:"Paymaster Bundler",pageUrl:"paymaster-bundler",wip:!0}),(0,a.jsx)("div",{className:"rounded-lg bg-gray-900 px-4 py-6 text-white",children:(0,a.jsx)(PaymasterBundlerDemo,{})}),(0,a.jsx)(NewGuide,{})]})]})}},97832:function(e,t,n){"use strict";n.d(t,{R:function(){return generateContractHook}});var a=n(18269),r=n(33934);function generateContractHook(e){let{abi:t,...n}=e;return function(){let{chain:e}=(0,a.m)(),s=Object.values(n).map(e=>e.chain),o=null!=e?e:s.find(e=>(0,r.iV)().some(t=>e.id===t.id));return o&&o.id in n?n[o.id].deactivated?{abi:t,status:"deactivated",supportedChains:s}:{abi:t,address:n[o.id].address,status:"ready",supportedChains:s}:{abi:t,status:"onUnsupportedNetwork",supportedChains:s}}}},26158:function(e,t,n){"use strict";n.d(t,{p:function(){return useLoggedInUserCanAfford}});var a=n(98458),r=n(30838),s=n(94973),o=n(16775),i=n(53002),c=n(46981),l=n(36238);function getUnit(e){return"number"==typeof e?e:"wei"===e?0:Math.abs(l.Bd[e])}var u=n(73105);async function multicall_multicall(e,t){let{allowFailure:n=!0,chainId:a,contracts:r,...s}=t,o=e.getClient({chainId:a}),i=(0,c.s)(o,u.A,"multicall");return i({allowFailure:n,contracts:r,...s})}var d=n(73613);async function readContracts(e,t){let{allowFailure:n=!0,blockNumber:r,blockTag:s,...o}=t,i=t.contracts;try{let t=i.reduce((t,n,a)=>{let r=n.chainId??e.state.chainId;return{...t,[r]:[...t[r]||[],{contract:n,index:a}]}},{}),a=(await Promise.all(Object.entries(t).map(([t,a])=>multicall_multicall(e,{...o,allowFailure:n,blockNumber:r,blockTag:s,chainId:parseInt(t),contracts:a.map(({contract:e})=>e)})))).flat(),c=Object.values(t).flatMap(e=>e.map(({index:e})=>e));return a.reduce((e,t,n)=>(e&&(e[c[n]]=t),e),[])}catch(t){if(t instanceof a.uq)throw t;let promises=()=>i.map(t=>(0,d.L)(e,{...t,blockNumber:r,blockTag:s}));if(n)return(await Promise.allSettled(promises())).map(e=>"fulfilled"===e.status?{result:e.value,status:"success"}:{error:e.reason,result:void 0,status:"failure"});return await Promise.all(promises())}}async function getBalance_getBalance(e,t){let{address:n,blockNumber:l,blockTag:u,chainId:d,token:p,unit:m="ether"}=t;if(p)try{return getTokenBalance(e,{balanceAddress:n,chainId:d,symbolType:"string",tokenAddress:p})}catch(t){if(t instanceof a.uq){let t=await getTokenBalance(e,{balanceAddress:n,chainId:d,symbolType:"bytes32",tokenAddress:p}),a=(0,r.rR)((0,s.f)(t.symbol,{dir:"right"}));return{...t,symbol:a}}throw t}let h=e.getClient({chainId:d}),f=(0,c.s)(h,i.s,"getBalance"),y=await f(l?{address:n,blockNumber:l}:{address:n,blockTag:u}),g=e.chains.find(e=>e.id===d)??h.chain;return{decimals:g.nativeCurrency.decimals,formatted:(0,o.b)(y,getUnit(m)),symbol:g.nativeCurrency.symbol,value:y}}async function getTokenBalance(e,t){let{balanceAddress:n,chainId:a,symbolType:r,tokenAddress:s,unit:i}=t,c={abi:[{type:"function",name:"balanceOf",stateMutability:"view",inputs:[{type:"address"}],outputs:[{type:"uint256"}]},{type:"function",name:"decimals",stateMutability:"view",inputs:[],outputs:[{type:"uint8"}]},{type:"function",name:"symbol",stateMutability:"view",inputs:[],outputs:[{type:r}]}],address:s},[l,u,d]=await readContracts(e,{allowFailure:!1,contracts:[{...c,functionName:"balanceOf",args:[n],chainId:a},{...c,functionName:"decimals",chainId:a},{...c,functionName:"symbol",chainId:a}]}),p=(0,o.b)(l??"0",getUnit(i??u));return{decimals:u,formatted:p,symbol:d,value:l}}var p=n(21637),m=n(84855),h=n(6613),f=n(41012),y=n(18269);function useLoggedInUserCanAfford(e){let t=(0,y.m)();return function(e,t){let n=function(e={}){let{address:t,query:n={}}=e,a=(0,f.Z)(e),r=(0,h.x)({config:a}),s=function(e,t={}){return{async queryFn({queryKey:t}){let{address:n,scopeKey:a,...r}=t[1];if(!n)throw Error("address is required");let s=await getBalance_getBalance(e,{...r,address:n});return s??null},queryKey:function(e={}){return["balance",(0,p.OP)(e)]}(t)}}(a,{...e,chainId:e.chainId??r}),o=!!(t&&(n.enabled??!0));return(0,m.aM)({...n,...s,enabled:o})}({address:e});return!!n.data&&t<=n.data.value}(t.address,e)}},39485:function(e,t,n){"use strict";n.d(t,{_F:function(){return getCurrentEnvironment},qA:function(){return r}});var a,r,s,o=n(25566);function getCurrentEnvironment(){let e=o.env.NEXT_PUBLIC_ENVIRONMENT;if(void 0===e)return"localhost";let t=Object.values(r).find(t=>t===e);return null!=t?t:"localhost"}(a=r||(r={})).localhost="localhost",a.development="development",a.staging="staging",a.production="production",(s||(s={})).environment="NEXT_PUBLIC_ENVIRONMENT"},33934:function(e,t,n){"use strict";n.d(t,{iV:function(){return getChainsForEnvironment}});var a=n(87923),r=n(35085),s=n(39485);let o={[s.qA.localhost]:[a.L],[s.qA.development]:[a.L],[s.qA.staging]:[r.u,a.L],[s.qA.production]:[r.u,a.L]};function getChainsForEnvironment(e){return e||(e=(0,s._F)()),o[e]}},71660:function(e,t,n){"use strict";n.d(t,{e:function(){return getConnectorClient}});var a=n(30315),r=n(36855),s=n(4832),o=n(39803),i=n(76026);async function getConnectorClient(e,t={}){let n;if(t.connector){let{connector:e}=t,[a,r]=await Promise.all([e.getAccounts(),e.getChainId()]);n={accounts:a,chainId:r,connector:e}}else n=e.state.connections.get(e.state.current);if(!n)throw new i.aH;let c=t.chainId??n.chainId,l=n.connector;if(l.getClient)return l.getClient({chainId:c});let u=(0,s.T)(t.account??n.accounts[0]);u.address=(0,o.K)(u.address);let d=e.chains.find(e=>e.id===c),p=await n.connector.getProvider({chainId:c});if(t.account&&!n.accounts.some(e=>e.toLowerCase()===u.address.toLowerCase()))throw new i.JK({address:u.address,connector:l});return(0,a.e)({account:u,chain:d,name:"Connector Client",transport:e=>(function(e,t={}){let{key:n="custom",name:a="Custom Provider",retryDelay:s}=t;return({retryCount:o})=>(0,r.q)({key:n,name:a,request:e.request.bind(e),retryCount:t.retryCount??o,retryDelay:s,type:"custom"})})(p)({...e,retryCount:0})})}},73613:function(e,t,n){"use strict";n.d(t,{L:function(){return readContract}});var a=n(65459),r=n(46981);function readContract(e,t){let{chainId:n,...s}=t,o=e.getClient({chainId:n}),i=(0,r.s)(o,a.L,"readContract");return i(s)}},21637:function(e,t,n){"use strict";n.d(t,{OP:function(){return filterQueryOptions},if:function(){return structuralSharing},kq:function(){return hashFn}});var a=n(40300),r=n(48369);function structuralSharing(e,t){return(0,r.v)(e,t)?e:(0,a.Q$)(e,t)}function hashFn(e){return JSON.stringify(e,(e,t)=>!function(e){if(!hasObjectPrototype(e))return!1;let t=e.constructor;if(void 0===t)return!0;let n=t.prototype;return!!(hasObjectPrototype(n)&&n.hasOwnProperty("isPrototypeOf"))}(t)?"bigint"==typeof t?t.toString():t:Object.keys(t).sort().reduce((e,n)=>(e[n]=t[n],e),{}))}function hasObjectPrototype(e){return"[object Object]"===Object.prototype.toString.call(e)}function filterQueryOptions(e){let{_defaulted:t,behavior:n,gcTime:a,initialData:r,initialDataUpdatedAt:s,maxPages:o,meta:i,networkMode:c,queryFn:l,queryHash:u,queryKey:d,queryKeyHashFn:p,retry:m,retryDelay:h,structuralSharing:f,getPreviousPageParam:y,getNextPageParam:g,initialPageParam:b,_optimisticResults:w,enabled:x,notifyOnChangeProps:v,placeholderData:C,refetchInterval:j,refetchIntervalInBackground:S,refetchOnMount:P,refetchOnReconnect:A,refetchOnWindowFocus:N,retryOnMount:I,select:T,staleTime:O,suspense:k,throwOnError:B,config:_,connector:E,query:L,...q}=e;return q}},46981:function(e,t,n){"use strict";function getAction(e,t,n){let a=e[t.name];if("function"==typeof a)return a;let r=e[n];return"function"==typeof r?r:n=>t(e,n)}n.d(t,{s:function(){return getAction}})},67333:function(e,t,n){"use strict";n.d(t,{o:function(){return AccountNotFoundError}});var a=n(95950);let AccountNotFoundError=class AccountNotFoundError extends a.G{constructor({docsPath:e}={}){super("Could not find an Account to execute with this Action.\nPlease provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient.",{docsPath:e,docsSlug:"account"}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AccountNotFoundError"})}}},39630:function(e,t,n){"use strict";n.d(t,{$:function(){return getTransactionError}});var a=n(40009),r=n(44818),s=n(36074);function getTransactionError(e,{docsPath:t,...n}){let o=(()=>{let t=(0,s.k)(e,n);return t instanceof a.cj?e:t})();return new r.mk(o,{docsPath:t,...n})}},59494:function(e,t,n){"use strict";n.d(t,{f:function(){return parseEther}});var a=n(36238);function parseEther(e,t="wei"){return function(e,t){let[n,a="0"]=e.split("."),r=n.startsWith("-");if(r&&(n=n.slice(1)),a=a.replace(/(0+)$/,""),0===t)1===Math.round(Number(`.${a}`))&&(n=`${BigInt(n)+1n}`),a="";else if(a.length>t){let[e,r,s]=[a.slice(0,t-1),a.slice(t-1,t),a.slice(t)],o=Math.round(Number(`${r}.${s}`));(a=o>9?`${BigInt(e)+BigInt(1)}0`.padStart(e.length+1,"0"):`${e}${o}`).length>t&&(a=a.slice(1),n=`${BigInt(n)+1n}`),a=a.slice(0,t)}else a=a.padEnd(t,"0");return BigInt(`${r?"-":""}${n}${a}`)}(e,a.ez[t])}},84855:function(e,t,n){"use strict";n.d(t,{aM:function(){return useQuery}});var a=n(67663),r=n(21637);function useQuery(e){let t=(0,a.a)({...e,queryKeyHashFn:r.kq});return t.queryKey=e.queryKey,t}}},function(e){e.O(0,[8310,2483,7133,9971,6391,4971,2971,2472,1744],function(){return e(e.s=5636)}),_N_E=e.O()}]);